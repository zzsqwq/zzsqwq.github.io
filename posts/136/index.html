<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>“程序星编程之路”第二次作业题解 | Zs's Blog</title>
<meta name=keywords content="C语言,程序星"><meta name=description content='“程序星编程之路”第二次作业题解
A. Zs的回文质数
题目描述
读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\sim9$ 也是回文数。
思路
首先我们需要了解什么是回文数，以及什么是质数。
简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。
质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。
那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。
判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。
判断质数，我们可以在 $[2,\lfloor\sqrt{n}\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。
代码
#include<stdio.h>
#include<math.h>  //我们需要用到sqrt函数，因此需要引入数学库

int main()
{
    int n;
    bool flag = false;  // 标记 i 是否满足条件
    scanf("%d",&amp;n);
    for(int i=1;i<=n;i++)
    {
        flag = true;
        int p=i,j=0;
        while(p)   // 将 p 反转为 j 
        {
            j=j*10+p%10;
            p/=10;
        }
        if(j==i)
        {
            if(j==1) continue; // 特判 1
            if(j==2)           // 特判 2
            {
                printf("2\n");
                continue;
            }
            int sqrtj = sqrt(j);
            for(int k=2;k<=sqrtj;k++)  // 枚举 [2,sqrt(n)]
            {
                if(j%k==0)         // 如果能够整除(余数为0),那么是 j 的因子
                {
                    flag = false;
                    break;
                }
            }
            if(flag)
            {
                printf("%d\n",j);
            }
        }
        
    }
}
其他
因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。'><meta name=author content="zzsqwq"><link rel=canonical href=https://blog.zzsqwq.cn/posts/136/><meta name=google-site-verification content="G-WF7TH97J9X"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.zzsqwq.cn/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://blog.zzsqwq.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.zzsqwq.cn/images/favicon-32x32.ico><link rel=apple-touch-icon href=https://blog.zzsqwq.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.zzsqwq.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.zzsqwq.cn/posts/136/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WF7TH97J9X"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WF7TH97J9X")}</script><meta property="og:title" content="“程序星编程之路”第二次作业题解"><meta property="og:description" content='“程序星编程之路”第二次作业题解
A. Zs的回文质数
题目描述
读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\sim9$ 也是回文数。
思路
首先我们需要了解什么是回文数，以及什么是质数。
简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。
质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。
那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。
判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。
判断质数，我们可以在 $[2,\lfloor\sqrt{n}\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。
代码
#include<stdio.h>
#include<math.h>  //我们需要用到sqrt函数，因此需要引入数学库

int main()
{
    int n;
    bool flag = false;  // 标记 i 是否满足条件
    scanf("%d",&amp;n);
    for(int i=1;i<=n;i++)
    {
        flag = true;
        int p=i,j=0;
        while(p)   // 将 p 反转为 j 
        {
            j=j*10+p%10;
            p/=10;
        }
        if(j==i)
        {
            if(j==1) continue; // 特判 1
            if(j==2)           // 特判 2
            {
                printf("2\n");
                continue;
            }
            int sqrtj = sqrt(j);
            for(int k=2;k<=sqrtj;k++)  // 枚举 [2,sqrt(n)]
            {
                if(j%k==0)         // 如果能够整除(余数为0),那么是 j 的因子
                {
                    flag = false;
                    break;
                }
            }
            if(flag)
            {
                printf("%d\n",j);
            }
        }
        
    }
}
其他
因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.zzsqwq.cn/posts/136/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-12T23:13:00+00:00"><meta property="article:modified_time" content="2020-11-12T23:13:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="“程序星编程之路”第二次作业题解"><meta name=twitter:description content='“程序星编程之路”第二次作业题解
A. Zs的回文质数
题目描述
读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\sim9$ 也是回文数。
思路
首先我们需要了解什么是回文数，以及什么是质数。
简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。
质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。
那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。
判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。
判断质数，我们可以在 $[2,\lfloor\sqrt{n}\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。
代码
#include<stdio.h>
#include<math.h>  //我们需要用到sqrt函数，因此需要引入数学库

int main()
{
    int n;
    bool flag = false;  // 标记 i 是否满足条件
    scanf("%d",&amp;n);
    for(int i=1;i<=n;i++)
    {
        flag = true;
        int p=i,j=0;
        while(p)   // 将 p 反转为 j 
        {
            j=j*10+p%10;
            p/=10;
        }
        if(j==i)
        {
            if(j==1) continue; // 特判 1
            if(j==2)           // 特判 2
            {
                printf("2\n");
                continue;
            }
            int sqrtj = sqrt(j);
            for(int k=2;k<=sqrtj;k++)  // 枚举 [2,sqrt(n)]
            {
                if(j%k==0)         // 如果能够整除(余数为0),那么是 j 的因子
                {
                    flag = false;
                    break;
                }
            }
            if(flag)
            {
                printf("%d\n",j);
            }
        }
        
    }
}
其他
因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.zzsqwq.cn/posts/"},{"@type":"ListItem","position":2,"name":"“程序星编程之路”第二次作业题解","item":"https://blog.zzsqwq.cn/posts/136/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"“程序星编程之路”第二次作业题解","name":"“程序星编程之路”第二次作业题解","description":"“程序星编程之路”第二次作业题解 A. Zs的回文质数 题目描述 读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\\sim9$ 也是回文数。\n思路 首先我们需要了解什么是回文数，以及什么是质数。\n简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。\n质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。\n那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。\n判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。\n判断质数，我们可以在 $[2,\\lfloor\\sqrt{n}\\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。\n代码 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; //我们需要用到sqrt函数，因此需要引入数学库 int main() { int n; bool flag = false; // 标记 i 是否满足条件 scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { flag = true; int p=i,j=0; while(p) // 将 p 反转为 j { j=j*10+p%10; p/=10; } if(j==i) { if(j==1) continue; // 特判 1 if(j==2) // 特判 2 { printf(\u0026#34;2\\n\u0026#34;); continue; } int sqrtj = sqrt(j); for(int k=2;k\u0026lt;=sqrtj;k++) // 枚举 [2,sqrt(n)] { if(j%k==0) // 如果能够整除(余数为0),那么是 j 的因子 { flag = false; break; } } if(flag) { printf(\u0026#34;%d\\n\u0026#34;,j); } } } } 其他 因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。\n","keywords":["C语言","程序星"],"articleBody":"“程序星编程之路”第二次作业题解 A. Zs的回文质数 题目描述 读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\\sim9$ 也是回文数。\n思路 首先我们需要了解什么是回文数，以及什么是质数。\n简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。\n质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。\n那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。\n判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。\n判断质数，我们可以在 $[2,\\lfloor\\sqrt{n}\\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。\n代码 #include #include //我们需要用到sqrt函数，因此需要引入数学库 int main() { int n; bool flag = false; // 标记 i 是否满足条件 scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) { flag = true; int p=i,j=0; while(p) // 将 p 反转为 j { j=j*10+p%10; p/=10; } if(j==i) { if(j==1) continue; // 特判 1 if(j==2) // 特判 2 { printf(\"2\\n\"); continue; } int sqrtj = sqrt(j); for(int k=2;k\u003c=sqrtj;k++) // 枚举 [2,sqrt(n)] { if(j%k==0) // 如果能够整除(余数为0),那么是 j 的因子 { flag = false; break; } } if(flag) { printf(\"%d\\n\",j); } } } } 其他 因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。\n#include #include bool isprime(int k) //判断是否为质数，如果是质数返回true，如果不是返回false { if(k==1) return false; if(k==2) return true; for(int i=2;i\u003c=sqrt(k);i++) { if(k%i==0) return false; } return true; } bool ishw(int k) //判断是否为回文数，如果是返回true，如果不是返回false { int ans=0; int temp = k; //temp作为一个k的复制版，因为后续需要用到k，新定义一个作为备份 while(k) { ans = ans*10 + k%10; k/=10; } if(temp == ans) { return true; } else return false; } int main() { int n; scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) { if(isprime(i) \u0026\u0026 ishw(i)) //如果既是质数也是回文数 { printf(\"%d\\n\",i); } } } B. Wcx的杨辉三角 题目描述 读入一个整数 $n$ ，输出杨辉三角的前 $n$ 行。\n思路 首先这道题我们需要了解一下杨辉三角 ，大家小学到高中应该都了解过。\n那么如何计算杨辉三角，首先我们可以知道的是杨辉三角的第 $i$ 行就是$C_i^0\\sim C_i^i$ ，但是我们考虑一下如何计算组合数，是用阶乘对吧，但是阶乘就涉及到一个连乘，对于这个题，我数据范围写的是 $1\\le n \\le 40$ ，很明显，阶乘不可行。而且写起来挺麻烦的。\n那么我们考虑一个组合数的性质 $$ C_n^i = C_{n-1}^i + C_{n-1}^{i-1} $$\n看起来很高大上对吧，简单点说就是杨辉三角里面一个数的值等于两肩之和，那么基于这个性质，我们很容易想到，我们可以用一个二维数组，定义 $f[i][j]$ 为第 $i$ 行的第 $j$ 个数，那么可以得到\n当 $j==1$ 或 $j==i$ ，则 $f[i][j] = 1$ ，也就是，当它为这一行的第一个或者最后一个，那么它就是 $1$\n如果不是上述条件，则 $f[i][j] = f[i-1][j] + f[i-1][j-1]$ ，也就是等于两肩之和。\n还有一个需要注意的问题就是，这个题的 $n$ 最大值是 40，这个时候已经超出了 $int$ 的范围，因此我们需要将二维数组定义为 $long: :long$ 。\n代码 #include int main() { long long a[105][105] = {0}; //全都初始化为 0 int n = 0; scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) //这里我用的是 1~n 而不是 0~n-1 { for(int j=1;j\u003c=i;j++) { if(j==1 || j==i) { printf(\"%lld \",a[i][j]=1); } else { printf(\"%lld \",a[i][j]=a[i-1][j-1]+a[i-1][j]); } } printf(\"\\n\"); } } 其他 这道题主要是对二维数组的考察。\n注意我们遇到第五个点过不去的时候，应该试一下最大的值 $40$ ，会发现有负数，显然是溢出问题，我们就能知道问题的解决办法了。\nC. Zh的约瑟夫环问题 题目描述 有 $n$ 个人围成一圈，顺序排号，从第一个开始报数(从 $1$ 到 $m$ 报数)，凡报到 $m$ 的人退出圈子，问最后留下的是几号.\n思路 约瑟夫问题是个很经典的问题，可能又叫什么猴子选大王什么的，特多变体。\n这个题其实就是一个纯模拟题，主要是对数组的考察。我们可以考虑开一个布尔数组 vis 用来标记某个人是否出圈，如果出圈了我们给他设置为 true ，如果没有出圈就是 false 。\n然后开一个报数到多少的变量cnt，开一个当前谁报数的变量pot，然后来模拟这个过程。如果 cnt 增长到了 m ，我们将 pot 出圈，也就是 vis[pot] = true ，然后在场的人数减一，当只剩下一人的时候，我们遍历 vis 数组中的每个元素，如果它的 vis 值为 false ，即没有出队，则将他输出。\n还有一个要注意的问题就是这是一个环，那么我们只需要判断一下当 pot 为 $n+1$ 的时候将他置为 $1$ 即可，这就模拟了一个环的性质。\n代码 #include #include #include #include #include using namespace std; int n,m; int vis[1005]; //vis[i] = true 已经淘汰 vis[i] = false 未被淘汰 int main() { scanf(\"%d%d\",\u0026n,\u0026m); int cnt = 1; //报数到多少 int pot = 1; //当前是谁报数 int exist = n; //在场的人数 while(exist \u003e 1) { cnt=0; while(1) { if(!vis[pot]) //如果没有出圈 { cnt++; if(cnt==m) { vis[pot] = true; exist--; break; } } pot++; if(pot==n+1) pot=1; //模拟环 } } for(int i=1;i\u003c=n;i++) { if(vis[i] == false) printf(\"%d\",i); } return 0; } 其他 上面的想法是比较好理解的形式。\n我们考虑一下模拟环，也就是使得 pot 指针处在一定的范围内，如果超出了将他重新置到头部，那么我们可以联想到取模，在模拟环时使用取模来实现，大家可以下去自己尝试，这有点像魏辰旭第一节课讲的那个字符串的问题。\n因为这道题只关心谁活了下来，所以还有一个比较简单的解法，我看在作业中也有几位同学给出了这个较简单的解法，如果理解了上述思想，看这个代码应该不难理解，大家可以对照代码自行思考。\n#include int n,m; int pot = 0; int main() { scanf(\"%d%d\",\u0026n,\u0026m); for(int i=2;i\u003c=n;i++) { pot = (pot+m)%i; } printf(\"%d\",pot+1); } 提示：n个人的约瑟夫环杀掉一个人后组成一个新的人数为 n-1 的约瑟夫环\n","wordCount":"463","inLanguage":"en","datePublished":"2020-11-12T23:13:00Z","dateModified":"2020-11-12T23:13:00Z","author":{"@type":"Person","name":"zzsqwq"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zzsqwq.cn/posts/136/"},"publisher":{"@type":"Organization","name":"Zs's Blog","logo":{"@type":"ImageObject","url":"https://blog.zzsqwq.cn/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.zzsqwq.cn/ accesskey=h title="Zs's Blog (Alt + H)">Zs's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.zzsqwq.cn/about title=About><span>About</span></a></li><li><a href=https://blog.zzsqwq.cn/archives title=Posts><span>Posts</span></a></li><li><a href=https://blog.zzsqwq.cn/friends title=Friends><span>Friends</span></a></li><li><a href=https://blog.zzsqwq.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.zzsqwq.cn/>Home</a>&nbsp;»&nbsp;<a href=https://blog.zzsqwq.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">“程序星编程之路”第二次作业题解</h1><div class=post-meta><span title='2020-11-12 23:13:00 +0000 UTC'>November 12, 2020</span>&nbsp;·&nbsp;zzsqwq&nbsp;|&nbsp;<a href=https://github.com/zzsqwq/zzsqwq.github.io/tree/master/content/posts/%e2%80%9c%e7%a8%8b%e5%ba%8f%e6%98%9f%e7%bc%96%e7%a8%8b%e4%b9%8b%e8%b7%af%e2%80%9d%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bd%9c%e4%b8%9a%e9%a2%98%e8%a7%a3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e6%98%9f%e7%bc%96%e7%a8%8b%e4%b9%8b%e8%b7%af%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bd%9c%e4%b8%9ahttpswwwluogucomcncontest36509%e9%a2%98%e8%a7%a3 aria-label=“程序星编程之路”第二次作业题解>“程序星编程之路”第二次作业题解</a><ul><li><a href=#a-zs%e7%9a%84%e5%9b%9e%e6%96%87%e8%b4%a8%e6%95%b0httpswwwluogucomcnproblemu138527contestid36509 aria-label="A. Zs的回文质数">A. Zs的回文质数</a><ul><li><a href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0 aria-label=题目描述>题目描述</a></li><li><a href=#%e6%80%9d%e8%b7%af aria-label=思路>思路</a></li><li><a href=#%e4%bb%a3%e7%a0%81 aria-label=代码>代码</a></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li></ul></li><li><a href=#b-wcx%e7%9a%84%e6%9d%a8%e8%be%89%e4%b8%89%e8%a7%92httpswwwluogucomcnproblemu138528contestid36509 aria-label="B. Wcx的杨辉三角">B. Wcx的杨辉三角</a><ul><li><a href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-1 aria-label=题目描述>题目描述</a></li><li><a href=#%e6%80%9d%e8%b7%af-1 aria-label=思路>思路</a></li><li><a href=#%e4%bb%a3%e7%a0%81-1 aria-label=代码>代码</a></li><li><a href=#%e5%85%b6%e4%bb%96-1 aria-label=其他>其他</a></li></ul></li><li><a href=#c-zh%e7%9a%84%e7%ba%a6%e7%91%9f%e5%a4%ab%e7%8e%af%e9%97%ae%e9%a2%98httpswwwluogucomcnproblemu138529contestid36509 aria-label="C. Zh的约瑟夫环问题">C. Zh的约瑟夫环问题</a><ul><li><a href=#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-2 aria-label=题目描述>题目描述</a></li><li><a href=#%e6%80%9d%e8%b7%af-2 aria-label=思路>思路</a></li><li><a href=#%e4%bb%a3%e7%a0%81-2 aria-label=代码>代码</a></li><li><a href=#%e5%85%b6%e4%bb%96-2 aria-label=其他>其他</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=程序星编程之路第二次作业httpswwwluogucomcncontest36509题解><a href=https://www.luogu.com.cn/contest/36509>“程序星编程之路”第二次作业</a>题解<a hidden class=anchor aria-hidden=true href=#程序星编程之路第二次作业httpswwwluogucomcncontest36509题解>#</a></h2><h3 id=a-zs的回文质数httpswwwluogucomcnproblemu138527contestid36509>A. <a href="https://www.luogu.com.cn/problem/U138527?contestId=36509">Zs的回文质数</a><a hidden class=anchor aria-hidden=true href=#a-zs的回文质数httpswwwluogucomcnproblemu138527contestid36509>#</a></h3><h4 id=题目描述>题目描述<a hidden class=anchor aria-hidden=true href=#题目描述>#</a></h4><p>读入一个整数 $n$ ，输出 $[1,n]$ 的所有回文质数，我们规定 $1\sim9$ 也是回文数。</p><h4 id=思路>思路<a hidden class=anchor aria-hidden=true href=#思路>#</a></h4><p>首先我们需要了解什么是<a href=https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E6%95%B0>回文数</a>，以及什么是<a href=https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0>质数</a>。</p><p>简单点说，回文数就是正着读反着读都是一样的，也就是对称的，形如 $abcba $ 或者 $123321$ 这样的。</p><p>质数的话，对于一个数 $n$ ，如果他是质数，那它除了 $1$ 和 $n$ 没有其他因子。例如 $2,3,5,7,11$ 这样的。</p><p>那么接下来我们考虑一下解决这个问题应该怎么做，首先我们看一下数据范围，$[1,100000]$ ，还是挺小的，我们可以考虑直接枚举每一个数来判断它是不是回文数，然后再判断一下是不是质数，如果两个都满足，我们就输出它。</p><p>判断回文数，我们可以考虑到 NOJ05 幸运数 一题的解题思路，也就是说我们把一个数倒置过来，好比一个数 $xyz$ 倒置成 $zyx$ ，然后判断是否 $xyz == zyx$ ，如果相等的话就是回文数，如果不相等就不是。</p><p>判断质数，我们可以在 $[2,\lfloor\sqrt{n}\rfloor]$ 枚举它的因子，这个的完备性我上课的时候证明过，不再赘述。这里需要注意 $1,2$ 需要特判一下。</p><h4 id=代码>代码<a hidden class=anchor aria-hidden=true href=#代码>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>#include&lt;math.h&gt;  </span><span class=c1>//我们需要用到sqrt函数，因此需要引入数学库
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>flag</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>  <span class=c1>// 标记 i 是否满足条件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>flag</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p</span><span class=o>=</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=p>)</span>   <span class=c1>// 将 p 反转为 j 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>=</span><span class=n>j</span><span class=o>*</span><span class=mi>10</span><span class=o>+</span><span class=n>p</span><span class=o>%</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>/=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>j</span><span class=o>==</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>j</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span> <span class=c1>// 特判 1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>j</span><span class=o>==</span><span class=mi>2</span><span class=p>)</span>           <span class=c1>// 特判 2
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>sqrtj</span> <span class=o>=</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;=</span><span class=n>sqrtj</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>)</span>  <span class=c1>// 枚举 [2,sqrt(n)]
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>j</span><span class=o>%</span><span class=n>k</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>         <span class=c1>// 如果能够整除(余数为0),那么是 j 的因子
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>flag</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>flag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h4><p>因为我们讲到这里的时候，我们没讲函数，但是这道题如果我们把判断是否为回文数，判断是否为质数，都另成一个函数模块，将使得程序变得更加简洁。我在这里也将函数版本的贴出来，有兴趣的可以看一下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;math.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isprime</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span>  <span class=c1>//判断是否为质数，如果是质数返回true，如果不是返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>==</span><span class=mi>2</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=nf>sqrt</span><span class=p>(</span><span class=n>k</span><span class=p>);</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>%</span><span class=n>i</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ishw</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=c1>//判断是否为回文数，如果是返回true，如果不是返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span> <span class=c1>//temp作为一个k的复制版，因为后续需要用到k，新定义一个作为备份
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ans</span> <span class=o>=</span> <span class=n>ans</span><span class=o>*</span><span class=mi>10</span> <span class=o>+</span> <span class=n>k</span><span class=o>%</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span><span class=o>/=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>temp</span> <span class=o>==</span> <span class=n>ans</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nf>isprime</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nf>ishw</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>  <span class=c1>//如果既是质数也是回文数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=b-wcx的杨辉三角httpswwwluogucomcnproblemu138528contestid36509>B. <a href="https://www.luogu.com.cn/problem/U138528?contestId=36509">Wcx的杨辉三角</a><a hidden class=anchor aria-hidden=true href=#b-wcx的杨辉三角httpswwwluogucomcnproblemu138528contestid36509>#</a></h3><h4 id=题目描述-1>题目描述<a hidden class=anchor aria-hidden=true href=#题目描述-1>#</a></h4><p>读入一个整数 $n$ ，输出杨辉三角的前 $n$ 行。</p><h4 id=思路-1>思路<a hidden class=anchor aria-hidden=true href=#思路-1>#</a></h4><p>首先这道题我们需要了解一下<a href=https://baike.baidu.com/item/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92>杨辉三角</a> ，大家小学到高中应该都了解过。</p><p>那么如何计算杨辉三角，首先我们可以知道的是杨辉三角的第 $i$ 行就是$C_i^0\sim C_i^i$ ，但是我们考虑一下如何计算组合数，是用阶乘对吧，但是阶乘就涉及到一个连乘，对于这个题，我数据范围写的是 $1\le n \le 40$ ，很明显，阶乘不可行。而且写起来挺麻烦的。</p><p>那么我们考虑一个组合数的性质
$$
C_n^i = C_{n-1}^i + C_{n-1}^{i-1}
$$</p><p>看起来很高大上对吧，简单点说就是杨辉三角里面一个数的值等于两肩之和，那么基于这个性质，我们很容易想到，我们可以用一个二维数组，定义 $f[i][j]$ 为第 $i$ 行的第 $j$ 个数，那么可以得到</p><ul><li><p>当 $j==1$ 或 $j==i$ ，则 $f[i][j] = 1$ ，也就是，当它为这一行的第一个或者最后一个，那么它就是 $1$</p></li><li><p>如果不是上述条件，则 $f[i][j] = f[i-1][j] + f[i-1][j-1]$ ，也就是等于两肩之和。</p></li></ul><p><strong>还有一个需要注意的问题就是，这个题的 $n$ 最大值是 40，这个时候已经超出了 $int$ 的范围，因此我们需要将二维数组定义为 $long: :long$ 。</strong></p><h4 id=代码-1>代码<a hidden class=anchor aria-hidden=true href=#代码-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>long</span> <span class=n>a</span><span class=p>[</span><span class=mi>105</span><span class=p>][</span><span class=mi>105</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span> <span class=c1>//全都初始化为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>  <span class=c1>//这里我用的是 1~n 而不是 0~n-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>j</span><span class=o>==</span><span class=mi>1</span> <span class=o>||</span> <span class=n>j</span><span class=o>==</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%lld &#34;</span><span class=p>,</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%lld &#34;</span><span class=p>,</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=其他-1>其他<a hidden class=anchor aria-hidden=true href=#其他-1>#</a></h4><p>这道题主要是对二维数组的考察。</p><p>注意我们遇到第五个点过不去的时候，应该试一下最大的值 $40$ ，会发现有负数，显然是溢出问题，我们就能知道问题的解决办法了。</p><h3 id=c-zh的约瑟夫环问题httpswwwluogucomcnproblemu138529contestid36509>C. <a href="https://www.luogu.com.cn/problem/U138529?contestId=36509">Zh的约瑟夫环问题</a><a hidden class=anchor aria-hidden=true href=#c-zh的约瑟夫环问题httpswwwluogucomcnproblemu138529contestid36509>#</a></h3><h4 id=题目描述-2>题目描述<a hidden class=anchor aria-hidden=true href=#题目描述-2>#</a></h4><p>有 $n$ 个人围成一圈，顺序排号，从第一个开始报数(从 $1$ 到 $m$ 报数)，凡报到 $m$ 的人退出圈子，问最后留下的是几号.</p><h4 id=思路-2>思路<a hidden class=anchor aria-hidden=true href=#思路-2>#</a></h4><p>约瑟夫问题是个很经典的问题，可能又叫什么猴子选大王什么的，特多变体。</p><p>这个题其实就是一个纯模拟题，主要是对数组的考察。我们可以考虑开一个布尔数组 <strong>vis</strong> 用来标记某个人是否出圈，如果出圈了我们给他设置为 <strong>true</strong> ，如果没有出圈就是 <strong>false</strong> 。</p><p>然后开一个报数到多少的变量<strong>cnt</strong>，开一个当前谁报数的变量<strong>pot</strong>，然后来模拟这个过程。如果 <strong>cnt</strong> 增长到了 <strong>m</strong> ，我们将 <strong>pot</strong> 出圈，也就是 <strong>vis[pot] = true</strong> ，然后在场的人数减一，当只剩下一人的时候，我们遍历 <strong>vis</strong> 数组中的每个元素，如果它的 vis 值为 <strong>false</strong> ，即没有出队，则将他输出。</p><p>还有一个要注意的问题就是这是一个环，那么我们只需要判断一下当 <strong>pot</strong> 为 $n+1$ 的时候将他置为 $1$ 即可，这就模拟了一个环的性质。</p><h4 id=代码-2>代码<a hidden class=anchor aria-hidden=true href=#代码-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;cmath&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>using</span> <span class=n>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>vis</span><span class=p>[</span><span class=mi>1005</span><span class=p>];</span> <span class=c1>//vis[i] = true 已经淘汰 vis[i] = false 未被淘汰
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>,</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>    <span class=c1>//报数到多少
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>pot</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>    <span class=c1>//当前是谁报数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>exist</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>//在场的人数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>exist</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>vis</span><span class=p>[</span><span class=n>pot</span><span class=p>])</span> <span class=c1>//如果没有出圈
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>cnt</span><span class=o>==</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>vis</span><span class=p>[</span><span class=n>pot</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>exist</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>pot</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>pot</span><span class=o>==</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=n>pot</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=c1>//模拟环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>vis</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=nb>false</span><span class=p>)</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=n>i</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=其他-2>其他<a hidden class=anchor aria-hidden=true href=#其他-2>#</a></h4><p>上面的想法是比较好理解的形式。</p><p>我们考虑一下模拟环，也就是使得 <strong>pot</strong> 指针处在一定的范围内，如果超出了将他重新置到头部，那么我们可以联想到取模，在模拟环时使用取模来实现，大家可以下去自己尝试，这有点像魏辰旭第一节课讲的那个字符串的问题。</p><p>因为这道题只关心谁活了下来，所以还有一个比较简单的解法，我看在作业中也有几位同学给出了这个较简单的解法，如果理解了上述思想，看这个代码应该不难理解，大家可以对照代码自行思考。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>pot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>n</span><span class=p>,</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pot</span> <span class=o>=</span> <span class=p>(</span><span class=n>pot</span><span class=o>+</span><span class=n>m</span><span class=p>)</span><span class=o>%</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=n>pot</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>提示：n个人的约瑟夫环杀掉一个人后组成一个新的人数为 n-1 的约瑟夫环</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.zzsqwq.cn/tags/c%E8%AF%AD%E8%A8%80/>C语言</a></li><li><a href=https://blog.zzsqwq.cn/tags/%E7%A8%8B%E5%BA%8F%E6%98%9F/>程序星</a></li></ul><nav class=paginav><a class=prev href=https://blog.zzsqwq.cn/posts/141/><span class=title>« Prev</span><br><span>Ubuntu18.04优化教程</span>
</a><a class=next href=https://blog.zzsqwq.cn/posts/114/><span class=title>Next »</span><br><span>Visual Studio 2019 中 OpenCV 配置教程</span></a></nav></footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("pref-theme");getTheme=getTheme??"preferred_color_scheme";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","zzsqwq/hugo-blog-comment"),s.setAttribute("data-repo-id","R_kgDOGgU1qQ"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGgU1qc4CSX1m"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.zzsqwq.cn/>Zs's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> | <a href=http://beian.miit.gov.cn/ target=_blank>鲁ICP备2020034310号</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),sendMessage({setConfig:{theme:"light"}})):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),sendMessage({setConfig:{theme:"dark"}}))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>